" TODO: word with boundaries search
" TODO: and search
" TODO include search for related snail-, camel-, etc, case

" Always show signs column
augroup augroup_nilsboy_quickfix
  autocmd!
  autocmd BufEnter * execute 'sign define nilsboy_quickfixEmpty'
  autocmd BufEnter * execute 'execute ":sign place 9999 line=1
      \ name=nilsboy_quickfixEmpty buffer=".bufnr("")'
augroup END

let g:quickfix_mode = ''
function! s:toggleNavigationType() abort
    if g:quickfix_mode == 'quickfix'
      silent call nilsboy_quickfix#setNavigationType('locationlist')
      call INFO("Locationlist navigation activated")
    else
      silent call nilsboy_quickfix#setNavigationType('quickfix')
      call INFO("Quickfix navigation activated")
    endif
endfunction

" TODO make mappings move through lists by history
function! nilsboy_quickfix#setNavigationType(type) abort
    if a:type == 'quickfix'
      let g:quickfix_mode = 'quickfix'
      nnoremap <silent> <tab> :copen<cr>
      nnoremap <silent> <c-n> :silent! cnext<cr>
      nnoremap <silent> <c-p> :silent! cprevious<cr>
    else
      let g:quickfix_mode = 'locationlist'
      nnoremap <silent> <tab> :lopen<cr>
      nnoremap <silent> <c-n> :silent! lnext<cr>
      nnoremap <silent> <c-p> :silent! lprevious<cr>
    endif
endfunction

call nilsboy_quickfix#setNavigationType('quickfix')
nnoremap <leader>gl :call <SID>toggleNavigationType()<cr>

function! s:bufferDir() abort
  return expand("%:p:h")
endfunction

let s:ignore_file = g:vim.contrib.etc.dir . 'ignore-files'
let s:grep_command = 'grep -inHR --exclude-from ' . s:ignore_file
if executable('ag')
  let s:grep_command = 'ag --nogroup --nocolor --column '
        \ . ' --ignore-case --all-text'
        \ . ' -p ' . s:ignore_file
endif

nnoremap <silent> <leader>f <nop>
nnoremap <silent> <leader>ff :call <SID>search({})<cr>
vnoremap <silent> <leader>ff y:call <SID>search({
      \ 'term': @"})<cr>
nnoremap <silent> <leader>fB :call <SID>search({
      \ 'term': input('Search: '),
      \ 'matchBasenameOnly': 1})<cr>

nnoremap <silent> <leader>fw yiw:call <SID>search({
      \ 'term': @" })<cr>
nnoremap <silent> <leader>fr yiw:call <SID>search({
      \ 'term': '\b' . @" . '\b'})<cr>
nnoremap <silent> <leader>fW yiW:call <SID>search({
      \ 'term': @"})<cr>
nnoremap <silent> <leader>fi :call <SID>search({
      \ 'term': input('Search: ')})<cr>

nnoremap <silent> <leader>fsf yiw:call <SID>search({
      \ 'term': @",
      \ 'path': '~/src/'})<cr>
vnoremap <silent> <leader>fsf y:call <SID>search({
      \ 'term': @", 
      \ 'path': '~/src/'})<cr>
nnoremap <silent> <leader>fsW yiW:call <SID>search({
      \ 'term': @", 
      \ 'path': '~/src/'})<cr>
nnoremap <silent> <leader>fsi :call <SID>search({
      \ 'term': input('Search: '), 
      \ 'path': '~/src/'})<cr>

nnoremap <silent> <leader>fd :call <SID>search({
      \ 'path': <SID>bufferDir()})<cr>
nnoremap <silent> <leader>fdi :call <SID>search({
      \ 'term': input('Search: '),
      \ 'path': <SID>bufferDir()})<cr>
nnoremap <silent> <leader>ft :call <SID>search({
      \ 'term': 'todo'})<cr>

" nnoremap <silent> <leader>fb yiw:call <SID>search({
"       \ 'term': @", 
"       \ 'path': expand('%:p'),
"       \ 'find': 0})<cr>

" Search for keyword under cursor inside buffer
nmap <silent> <leader>fb [I

nnoremap <silent> <leader>df :call <SID>search({
      \ 'path': $HOME . '/src/sql/'})<cr>

" vim config search
nnoremap <silent> <leader>vff yiw:call <SID>search({
      \ 'term': @",
      \ 'path': g:vim.etc.dir})<cr>
vnoremap <silent> <leader>vff y:call <SID>search({
      \ 'term': @", 
      \ 'path': g:vim.etc.dir})<cr>
nnoremap <silent> <leader>vfW yiW:call <SID>search({
      \ 'term': @", 
      \ 'path': g:vim.etc.dir})<cr>
nnoremap <silent> <leader>vfi :call <SID>search({
      \ 'term': input('Search: '), 
      \ 'path': g:vim.etc.dir})<cr>

" vim plugin search
" TODO: search all plugin related dirs: config, tags/docs, bundle
nnoremap <silent> <leader>vpff yiw:call <SID>search({
      \ 'path': g:vim.bundle.dir})<cr>
nnoremap <silent> <leader>vpfw yiw:call <SID>search({
      \ 'term': @", 
      \ 'path': g:vim.bundle.dir})<cr>
nnoremap <silent> <leader>vpfi :call <SID>search({
      \ 'term': input('Search: '), 
      \ 'path': g:vim.bundle.dir})<cr>
nnoremap <silent> <leader>vpft :call <SID>search({
      \ 'term': expand('%:t:r'),
      \ 'path': g:vim.bundle.dir})<cr>
nnoremap <silent> <leader>vph :execute 'Help ' . expand('%:t:r')<cr>

let s:searchType = 'all'
let s:searchLimit = '500'
nnoremap <leader>fSS :call <SID>setVar('searchType', 'all')<cr>
nnoremap <leader>fSf :call <SID>setVar('searchType', 'files')<cr>
nnoremap <leader>fSg :call <SID>setVar('searchType', 'grep')<cr>
nnoremap <leader>fSl :call <SID>toggleVar('searchLimit', '500', '')<cr>

function! s:toggleVar(var, value1, value2) abort
  execute 'let current = s:' . a:var
  let next = a:value1
  if current == a:value1
    let next = a:value2
  endif
  execute 'let s:' . a:var . ' = "' . next . '"'
  call INFO('Setting ' . a:var . ' to: ' . next)
endfunction

function! s:setVar(var, value) abort
  execute 'let s:' . a:var . ' = "' . a:value . '"'
  call INFO('Setting ' . a:var . ' to: ' . a:value)
endfunction

command! -bang -nargs=1 Search call <SID>search({'term': <q-args>})
function! s:search(options) abort
  let term = get(a:options, 'term', '')
  let find = get(a:options, 'find', '1')
  let grep = get(a:options, 'grep', '1')
  let matchBasenameOnly = get(a:options, 'matchBasenameOnly', '0')

  let findTerm = term
  if matchBasenameOnly
    let findTerm = '\/.*' . term . '[^/]*$'
  endif

  let project_dir = FindRootDirectory()
  if project_dir == ''
    let project_dir = s:bufferDir()
  endif
  let path = get(a:options, 'path', project_dir)
  let path = fnamemodify(path, ':p')

  if term != ''
    " call INFO('Searching for ' . term . ' in ' . path)
  endif

  let grepprg = s:grep_command

  let limit = ''
  if s:searchLimit
    let limit = ' -' . s:searchLimit
  endif

  " /dev/null forces absolute paths if greping a single file
  let findprg = grepprg
        \ . ' -g ' . shellescape(findTerm)
        \ . ' ' . fnameescape(path) 
        \ . ' /dev/null'
        \ . ' \| head-warn ' . limit
        \ . ' \| sort-by-path-depth'

  let grepprg .= ' ' . shellescape(term) . ' ' . fnameescape(path)
        \ . ' /dev/null'
        \ . ' \| head-warn ' . limit

  " TODO: check if add to qf can be intercepted and input stopped 
  " after a certain amount of lines

  call nilsboy_quickfix#setNavigationType('quickfix')

  let &l:errorformat="%f:%l:%m,%f:%l%m,%f  %l%m,%f"
  let &l:makeprg = ''

  " if find && grep
  "   let &l:makeprg .= 'echo "### Find results ###" ; '
  " endif

  if find
    if s:searchType =~ '\v(files|all)'
      let &l:makeprg .= findprg
    endif
  endif

  if find && grep
    let &l:makeprg .= ' ; echo'
  endif

  if grep
    if s:searchType =~ '\v(grep|all)'
      if term != ''
        let &l:makeprg .= ' ; ' . grepprg
      endif
    endif
  endif
  let &l:makeprg = '(' . &l:makeprg . ')'
  Make
return
  copen
  if term != ''
    execute 'match Todo /\c\v' . term . '/'
  endif
  normal! j
endfunction

" TODO: replace internal function
function! nilsboy_quickfix#search(options) abort
  call <sid>search(a:options)
endfunction

nnoremap <silent><leader>o :call <SID>outline()<cr>
function! s:outline() abort
  let l:filetype = &filetype
  if exists("b:filetype")
    let l:filetype = b:filetype
  endif
  setlocal errorformat=%f:%l:%c:%m
  silent wall
  let &l:makeprg='outline --filename ' . expand('%:p') 
        \ . ' --filetype ' . l:filetype . ' 2>/dev/null'
  Make
endfunction

" TODO: Populate qf with open buffers:
" from https://vi.stackexchange.com/questions/2121/how-do-i-have-buffers-listed-in-a-quickfix-window-in-vim
nnoremap <silent><leader>vb :call <SID>buffers('')<cr>
nnoremap <silent><leader>vB :call <SID>buffers('!')<cr>
function! s:buffers(hidden) abort
    call nilsboy_quickfix#setNavigationType('quickfix')
    setlocal errorformat=%s"%f"%s
    cexpr execute(':buffers' . a:hidden)
    copen
endfunction

" http://dhruvasagar.com/2013/12/17/vim-filter-quickfix-list
function! s:FilterQuickfixList(bang, pattern)
  let cmp = a:bang ? '!~?' : '=~?'
  call setqflist(filter(getqflist(), "bufname(v:val['bufnr']) "
        \ . cmp . " a:pattern"))
endfunction
command! -bang -nargs=1 -complete=file QFilter call s:FilterQuickfixList(<bang>0, <q-args>)

" TODO nnoremap <silent><leader>vh :call _Denite('vim_help', 'help', '', '')<cr>
function! s:help(term) abort
    call nilsboy_quickfix#setNavigationType('quickfix')
    silent! execute 'helpgrep ' . a:term
    " silent! execute 'tag /' . a:term
    silent! copen
endfunction
command! -bang -nargs=1 -complete=file H call s:help(<q-args>)

function! nilsboy_quickfix#removeInvalid() abort
    call setqflist(filter(copy(getqflist()), 'v:val.valid == 1'))
endfunction

finish " #######################################################################

augroup s:quickfix
    " QuickFixCmd* Does not match :ltag
    autocmd QuickFixCmdPost [^l]* nnoremap <tab> :copen<cr>
    autocmd QuickFixCmdPost [^l]* botright copen
    autocmd QuickFixCmdPost [^l]* let b:isQuickfix = 1
    autocmd QuickFixCmdPost    l* nnoremap <tab> :lopen<cr>
    autocmd QuickFixCmdPost    l* botright lopen
augroup END

" TODO
nnoremap <silent> <leader>fp :call <SID>findInPath('')<cr>
function! s:findInPath(term) abort
  call nilsboy_quickfix#setNavigationType('quickfix')

  " Make sure the quickfix cwd isn't used as starting directory
  cclose

  let &l:makeprg="compgen -c \| sort -u"
  setlocal errorformat=%f
  Make
endfunction

" " TODO
" if len(getqflist()) > 0
"   " Quickfix error count
"   set statusline+=%{len(filter(getqflist(),'v:val.valid'))}
"   set statusline+=%{'/'}
"   set statusline+=%{len(getqflist())}
" endif

" if neobundle#tap('vim-operator-user') 
"   function! neobundle#hooks.on_post_source(bundle) abort

"     call operator#user#define('grep', 'OpGrep')
"     function! OpGrep(motion_wise)
" 	    let v = operator#user#visual_command_from_wise_name(a:motion_wise)
" 	    execute 'normal!' '`[' . v . '`]"xy'
"       " call INFO('X: ', getreg(operator#user#register()))
"       call <SID>grep({'term': @x})
"     endfunction

"   endfunction
"   call neobundle#untap()
" endif

" map <leader>g  <Plug>(operator-grep)
" map <leader>gs  <Plug>(operator-grep)

" TODO: does not work?
"       nnoremap <silent> <c-;> :silent! lnext<cr>
"       nnoremap <silent> <c-,> :silent! lprevious<cr>

function! AfterFormat(...) abort
    " does not reload otherwise
    silent! edit
endfunction

" nnoremap <silent> <leader>x :call FFormat()<cr>
function! FFormat() abort
    if ! exists('b:formatprg')
        return
    endif
    silent wall
    call neomake#Sh(b:formatprg, 'AfterFormat')
endfunction

command! -bang -nargs=1 FormatterSet call <SID>FormatterSet(<q-args>)
function! s:FormatterSet(formatterName) abort
    execute 'compiler ' . a:formatterName
endfunction

function! s:Cd(directory) abort
    if a:directory == ''
    elseif a:directory == 'project'
      call CdProjectRoot()
    elseif a:directory == 'project/..'
      call CdProjectRoot()
      lcd ..
    elseif a:directory == 'buffer_dir'
      execute "lcd" expand("%:p:h")
    else
      execute "lcd" a:directory
    endif
endfunction

