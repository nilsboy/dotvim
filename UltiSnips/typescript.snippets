priority 3

extends javascript

global !p

def toggle(t, opt):
  opts = t.split('|')
  pos = opts.index(opt)
  if len(opts) == pos + 1:
    pos = 0
  else:
    pos = pos + 1
  return opts[pos]

def toCamelCase(v):
  v = re.sub(r'.*/', r'', v)
  return re.sub(r'(\W)', r'', v.title())
  return v
  v = re.sub(r'^[\/\.]+', r'', v)
  return v
  return v.title()
  return re.sub(r'(\W)', r'', v.title())

def toMethodCase(v):
  v = re.sub(r'(.+)\.[^.]*$', r'\1', v)
  v = re.sub(r'^[\.\/]*', r'', v)
  return v[0:1].lower() + re.sub(r'(\W)', r'', v.title()[1:])

def classNameOld():
  v = snip.basename[0:1].upper()
  v = v + re.sub(r'(\W)', r'', snip.basename.title()[1:])
  return v

def className():
  v = snip.basename[0:1].upper()
  v = v + snip.basename[1:]
  return v

def classNameSingular():
  v = snip.basename[0:1].upper()
  v = v + snip.basename[1:]
  v = re.sub(r'Contexts$', r'Context', v)
  return v

def classNameWithoutContext():
  v = snip.basename[0:1].upper()
  v = v + snip.basename[1:]
  v = re.sub(r'Context$', r'', v)
  return v

def escape(v):
  return re.sub(r'`', r'\`', v)

endglobal

snippet class "class" w
export class `!p snip.rv = className()` {
  ${VISUAL}$0
}
endsnippet

snippet interface "interface" w
export interface `!p snip.rv = className()` {
  ${VISUAL}$0
}
endsnippet

# NOTE: typescript enums can not use objects as values
snippet enumNonObject "enum" w
export enum `!p snip.rv = className()` {
	${1:name} = ${0:value}
}
endsnippet

snippet enum "enum" b
// enum with type
export const ${1:`!p snip.rv = className()`} = {
  ${2:key1}: ${3:value1},$0
} as const

export type $1 = typeof $1[keyof typeof $1]
endsnippet

snippet con "constructor" b
public constructor($1) {
	${VISUAL}$0
}
endsnippet

snippet conContext "constructor" b
public constructor(dto: `!p snip.rv = className()`$1) {
	this.dto = dto$0
}
endsnippet

snippet super "super" b
super()
endsnippet

snippet a "await" w
await
endsnippet

snippet ignore "ignore" b
// @ts-ignore
endsnippet

snippet importEventEmitter "importEventEmitter" b
import {EventEmitter} from 'events'
endsnippet

snippet importNodeModule "importNodeModule" b
import cytoscape = require('cytoscape')
endsnippet

snippet eventAwait "eventAwait" b
await new Promise((fulfill) => ee.on("end", fulfill))
endsnippet

snippet xlsxReader "xlsxReader" b
#!/usr/bin/env ts-node

import xlsx from "xlsx"
import fs from "fs"

var buf = fs.readFileSync("${1:filename}")
var wb = xlsx.read(buf, { type: "buffer" })
const rows = xlsx.utils.sheet_to_json(wb.Sheets.${2:sheetname})
endsnippet

snippet exit "exit" b
// @ts-ignore
process.exit(1)
endsnippet

snippet init "init" b
#!/usr/bin/env ts-node

//$0
endsnippet

snippet ManyToOne "ManyToOne" b
@ManyToOne({
	entity: () => ${1:entity},
	joinColumn: `${2:joinColumn}`,
})
$1!: $1
endsnippet

snippet OneToMany "OneToMany" b
@OneToMany({
	entity: () => ${1:entity},
	mappedBy: "${2:remoteProperty}",
	joinColumn: "${3:id}",
	inverseJoinColumn: `${4:remoteId}`,
})
$1 = new Collection<$1>(this)
endsnippet

snippet iife "iife" w
(() => {${VISUAL}$0})()
endsnippet

snippet div "div" b
<div id="$0">
${VISUAL}
</div>
endsnippet

snippet diffdeep "diffdeep" b
const deep = require(`deep-diff`)
const diffs = deep.diff(expected, make.toJSON()) || []
endsnippet

snippet contenteditable "contenteditable" b
<h1 contenteditable
	@keyup=${(e: Event) => {
		this.productOffering.name = (e.target as HTMLElement).innerText
	}}
>${this.productOffering.name}</h1>
endsnippet

snippet sourceOfNodeCoreModule "dump source of a core module" b
// dump source of module.js:
node -e 'console.log(process.binding("natives").module)'
endsnippet

snippet exfun "export function" b
export async function ${1:name}($0) {
}
endsnippet

snippet errorClass "custom errorDefinition" b
// TODO: old version replace!
import { CustomError } from "ts-custom-error"
import { $2 } from "../$2"

export class $1 extends CustomError {
  $3: $2
  public constructor($3: $2) {
    super()
    this.$3 = $3$0

    this.message = `${this.constructor.name} - ...`

    // if (details) {
    //   this.message += ` / Details: ${details}`
    // }
  }
}

// errorSubClass
endsnippet

snippet errorSubClass "error definition" b
export class $0Error extends `!p snip.rv = className()` {}
endsnippet

snippet e "e" b
expect($0)
endsnippet

snippet uuidmodule "uuidmodule" b
// use v6 instead. Or at least v4?
import { v1 as uuidv1 } from 'uuid'
uuidv1()
endsnippet

snippet uuidv6 "uuidv6" b
import { v6 as uuidV6 } from "uuid-with-v6"
uuidV6()
endsnippet

snippet tag "tag" w
<$1>$0</$1>
endsnippet

snippet prom "promise" w
Promise<${VISUAL}$0>
endsnippet

snippet castForcably "castForcably" b
const $1 = _$1 as unknown as ${2:final type}[]
endsnippet

snippet className "className" b
this.constructor.name
endsnippet

snippet pushArrayToUndef "arrayPushToUndef" w
$1 = [...($1 || []),${2:{$0}}]
endsnippet

snippet methodStub "methodStub" b
async $1() : Promise<${2:void}> {
	throw new Error(\`Method not implemented: "$1()".\`)$0
}
endsnippet

snippet lodash "lodash" b
import _ from "lodash"
endsnippet

snippet testMockDate "dateMock" b
import MockDate from "mockdate"
MockDate.set(new Date())
endsnippet

snippet new "new" w
<$1> {$0
}
endsnippet

snippet httpfetch "fetch" b
const fetch = require("node-fetch")
const $2 = await fetch(\`${VISUAL}${1:url}\`, {
	method: \`${3:post}\`,
	body: \`\`,$0
	headers: { "Content-Type": "application/json" },
})
endsnippet

snippet arr "Array<>" w
Array<${VISUAL}$0>
endsnippet

snippet mockUuid "mockUuid" b
const mockedUuid = "11111111-6111-1111-1111-111111111111"
vi.mock("uuid-with-v6", () => ({
  v6: vi.fn(() => mockedUuid),
}))
endsnippet

snippet toBoolean "toBoolean" b
function toBoolean(value: string, defaultValue: boolean) {
  if (value === null || value === undefined || value === ``) {
    return defaultValue
  }
  if (value.match(/^(true)$/i)) {
    return true
  }
  if (value.match(/^(false)$/i)) {
    return false
  }
  throw new Error(`Invalid boolean: '${value}'`)
}
endsnippet

snippet ok "ok" b
assert.ok(${VISUAL}$0)
endsnippet

snippet classContextIterator "contextIterator" b
export class `!p snip.rv = className()`
  implements Iterator<${1:`!p snip.rv = classNameSingular()`}>
{
  dto: $1[]
  iterator: Iterator<$1>

  constructor(dto: $1[]) {
    this.dto = dto
  }

  [Symbol.iterator]() {
    this.iterator = this.dto[Symbol.iterator]()
    return this.iterator
  }

  next(
    ...args: [] | [undefined]
  ): IteratorResult<$1, any> {
    if (!this.iterator) {
      this.iterator = this.dto[Symbol.iterator]()
    }
    const next = this.iterator.next()
    return {
      value: new $1(next.value),
      done: next.done,
    }
  }

  toArray(): ProductContext[] {
    return Array.from(this)
  }

  length(): Number {
    return this.dto.length
  }
}
endsnippet

snippet classContext "classContext" b
import { `!p snip.rv = classNameWithoutContext()` } from "./types/`!p snip.rv = classNameWithoutContext()`"

export class `!p snip.rv = className()` extends `!p snip.rv = classNameWithoutContext()` {
  dto: `!p snip.rv = classNameWithoutContext()`

  public constructor(dto: `!p snip.rv = classNameWithoutContext()`) {
    super()
    this.dto = dto
  }
}
endsnippet

snippet iteratorToArray "IteratorToArray" b
Array.from($1)$0
endsnippet
