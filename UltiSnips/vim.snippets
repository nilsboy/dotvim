# TODO: add mappings for javascript expressions
# https://w0rp.com/blog/post/vim-script-for-the-javascripter/

global !p

def toCamelCase(v):
  v = re.sub(r'(.+)\.[^.]*$', r'\1', v)
  v = re.sub(r'[\.\/]*', r'', v)
  v = v.title()
  v = re.sub(r'[\W\-_]*', '', v)
  return v

def toMethodCase(v):
  v = re.sub(r'(.+)\.[^.]*$', r'\1', v)
  v = re.sub(r'[\.\/]*', r'', v)
  return v[0:1].lower() + re.sub(r'(\W)', r'', v.title()[1:])

def toSnakeCase(v):
  s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', v)
  return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

def ucfirst(v):
  return v[0].upper() + v[1:]

# clean file name to produce a name for vim var usage
def cfname(v):
  v = re.sub(r'\W', r'_', v).lower()
  v = re.sub(r'^my_', '', v)
  v = re.sub(r'vim_', '', v)
  v = re.sub(r'_vim', '', v)
  return 'My_' + v

def fncc(v):
  return toCamelCase(cfname(v))

endglobal

snippet command "command" b
function! $1(...) abort
  let cmd = join(a:000)
  ${VISUAL}$0
endfunction
command! -nargs=* ${1:`!p snip.rv = fncc(snip.basename)`}$2 call $1 (<f-args>)
endsnippet

snippet deinrc "Boilerplaite vimrc" b
set nocompatible

let g:plugin_dir = expand('~/.vim/dein')
let g:dein_dir = g:plugin_dir . '/repos/github.com/Shougo/dein.vim'
execute 'set runtimepath+=' . g:dein_dir

if !isdirectory(g:dein_dir)
  call mkdir(g:dein_dir, 'p')
  silent execute printf('!git clone --depth 1 %s %s', 'http://github.com/Shougo/dein.vim', g:dein_dir)
endif

call dein#begin(g:plugin_dir)

" Let dein manage dein
call dein#add('Shougo/dein.vim')
" call dein#add('Shougo/vimproc.vim', {'build': 'make'})
" call dein#add('Shougo/unite.vim')
  $0
call dein#end()

if dein#check_install() 
  call dein#install()
endif

filetype plugin indent on
endsnippet

snippet deinadd "Add bundle" b
call dein#add('$1')
$0
endsnippet

snippet n "name something" w
`!p snip.rv = fncc(snip.basename)`$0
endsnippet

snippet g "global variable name" w
g:`!p snip.rv = fncc(snip.basename)`${VISUAL}$0
endsnippet

snippet fun "Function" b
function! `!p snip.rv = fncc(snip.basename)`${1:name}($2) abort
  ${VISUAL}$0
endfunction
endsnippet

snippet if "if" b
if $1
  ${VISUAL}$0
endif
endsnippet

snippet elseif "elseif" b
elseif
endsnippet

snippet info "info" 
call INFO(${VISUAL}$0)
endsnippet

snippet infoo "info with 1 arg" 
call INFO('$1:', $1)
endsnippet

snippet echo "echo with 1 arg"
echo '$1:' . $1
endsnippet

snippet debug "debug" 
call DEBUG($0)
endsnippet

snippet plugin "Description" b
" ${0:description}
NeoBundle '${1:plugin name or github url}'
endsnippet

snippet neobundlepost "do something after plugin is loaded" b
if neobundle#tap('${1:`!v expand('%:t:r')`}') 
  function! neobundle#hooks.on_post_source(bundle) abort
    $0
  endfunction
  call neobundle#untap()
endif
endsnippet

snippet ifneo "if is neovim" b
if IsNeoVim()
  ${VISUAL}$0
endif
endsnippet

snippet autocmd "autocmd" b
augroup `!p snip.rv = fncc(snip.basename)`Augroup$1
  autocmd!
  autocmd ${VISUAL}$0
augroup END
endsnippet

snippet augroup "augroup" b
augroup `!p snip.rv = fncc(snip.basename)`Augroup$0
endsnippet

snippet c "concat" w
'$1:', $1$0
endsnippet

snippet q "quotes" w
'${VISUAL}$1'$0
endsnippet

snippet for "foreach" b
for ${1:var} in ${2:list}
  $0
endfor
endsnippet

snippet fori "for i in range" b
for ${1:i} in range(${2:1,10})
  $0
endfor
endsnippet

snippet whilei "whilei" b
let i = 0
while i <= $1
  let i = i + 1
  $0
endwhile
endsnippet

snippet while "while" b
while 1
  $0
endwhile
endsnippet

snippet exists "exists" w
exists('${VISUAL}${1:b:var}')
endsnippet

snippet existsFile "existsFile" w
filereadable($0)
endsnippet

snippet get "let with default" w
let $1 = get(${1/\:.*/:/}, '${1/^.*\://}', ${2:default})
endsnippet

snippet s "String" w
'${1:key}': '${2:value}',$0
endsnippet

# snippet n "Number" w
# '${1:key}': ${0:value},
# endsnippet

snippet a "Array" w
[
  \ ${VISUAL}$0
\ ],
endsnippet

snippet na "Named array" w
'${1:key}': [
  \ ${VISUAL}$0
\ ],
endsnippet

snippet o "Object" w
{
  \ ${VISUAL}$0
\ },
endsnippet

snippet no "Named object" w
'${1:key}': {
  \ ${VISUAL}$0
\ },
endsnippet

snippet exe "execute" w
execute '${VISUAL}$0'
endsnippet

snippet cut "cut a quoted string" w
' . $0 . '
endsnippet

snippet cr "<cr>" w
<cr>
endsnippet

snippet bar "<bar>" w
<bar>
endsnippet

snippet nop "<nop>" w
<nop>
endsnippet

snippet xx "here"
call INFO('### HERE`!v
  line('.')
  ` `!v
  expand('%:t') . ':' . line('.')
  ` ' . strftime("%F %T"))
endsnippet

snippet xxx "here"
call INFO('### HERE`!v
  line('.')
  ` `!v
  expand('%:t') . ':' . line('.')
(`!v strftime("%F")`)
  `')
endsnippet

snippet fileexists "check if a file exists" b
if filereadable($1)
  $0
endif
endsnippet

snippet push "array push" b
call add(${1:array}, ${VISUAL}${0:item})
endsnippet

snippet remove_array_entry "array remove at index" w
call remove(${1:array}, ${2:index})
endsnippet

snippet lead "<leader>" w
<leader>
endsnippet

snippet sil "<silent>" w
<silent>
endsnippet

snippet % "current buffer name" w
`!v expand('%:t')`
endsnippet

snippet %p "current buffer name" w
`!v expand('%:p')`
endsnippet

snippet b: "script specific buffer var" w
b:`!v expand('%:t:r')`_$0
endsnippet

snippet last "last array element" w
$1[len($1) - 1]
endsnippet

snippet arg "argument to normal var" w
let $1 = a:$1
endsnippet

snippet len "len" w
len($1) - 1
endsnippet

snippet map "map" b
nnoremap <silent> ${1:<leader>}$0
endsnippet

snippet "(.*)finish" "finish" r
finish
endsnippet

# getcurpos() is Neovim only
snippet getcurpos "getcurpos" b
let [bufnum, lnum, col, off] = getpos('.')
endsnippet

snippet substr "substr" w
${1:string}[${2:from} : ${3:to}]
endsnippet

snippet getchar "ask for a single character" b
echo 'Specify $1: '
let ${2:$1} = nr2char(getchar())
redraw
execute 'echo "' . $2 . '"'
endsnippet

snippet put "put" b
:put =${1:a:term . ':'}
endsnippet

snippet buf "buf" w
<buffer>
endsnippet

# getreg(operator#user#register())
snippet operator "operator" b
if neobundle#tap('vim-operator-user') 
  function! neobundle#hooks.on_post_source(bundle) abort
    call operator#user#define('${1:name}', '${3:Op`!p snip.rv = toCamelCase(t[1])`$2}')
    function! $3(motion_wise) abort
      let v = operator#user#visual_command_from_wise_name(a:motion_wise)
      execute 'normal!' '\`[' . v . '\`]"xy'
      ${6:execute "echo '" . @x . "'"}$0
    endfunction
  endfunction
  call neobundle#untap()
endif
map <leader>${5:mapping} <Plug>(operator-$1)
endsnippet

snippet setl "set local" b
let &l:$1 = $0
endsnippet

snippet set "set" b
let &$1 = $0
endsnippet

snippet replace "replace" w
let $1 = substitute(${1:input}, '${2:search\s\+}', '${3:replace}', 'g')
endsnippet

snippet if_already_loaded "ftplugin_done" b
if exists("b:`!p snip.rv = fncc(snip.basename)`FtpluginLoaded")
    finish
endif
let b:`!p snip.rv = fncc(snip.basename)`FtpluginLoaded = 1
$0
endsnippet

snippet saveCursorPosition "savecursorposition" b
let saved_cursor = getcurpos()
endsnippet

snippet restoreCursorPosition "restoreCursorPosition" b
call setpos('.', saved_cursor)
endsnippet

snippet setlocal "setlocal" b
let &l:$1 = $0
endsnippet

snippet	cword "expand cword" w
expand('<cword>')
endsnippet

snippet	cWORD "expand cWORD" w
expand('<cWORD>')
endsnippet

snippet joinmap "joinmap" w
call extend(${1:target}, ${2:source})
endsnippet

snippet clonemap "clonemap" w
let ${1:target} = {}
call extend(${1:target}, ${0:source})
endsnippet

snippet join "join" w
join(${1:list}, ${2:separator}$0)
endsnippet

snippet split "split" w
split(${1:src}, '${0:pattern}')
endsnippet

snippet listlength "listlength" w
len(${VISUAL}$0)
endsnippet

snippet appendToFile "appendToFile" b
call writefile(${1:list of lines}, ${0:filename}, 'a')
endsnippet

snippet match "match" w
let ${1:result} = []
call substitute(${2:source}, ${0:pattern}, '\=add($1, submatch(0))', 'g')
endsnippet

snippet matches "matches" w
${VISUAL}$1 =~ $0
endsnippet

snippet define "define" b
let &l:define = '\v^$0'
endsnippet

snippet startsWith "startsWith" w
  return stridx($1, '$0') == 0
endsnippet

snippet mapremoveKey "hash.removeKey" w
remove(${VISUAL}$1, ${2:key}$0)
endsnippet
